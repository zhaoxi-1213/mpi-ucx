#!/usr/bin/env python3
#
# Copyright (c) 2015-2025 Research Organization for Information Science
#                         and Technology (RIST). All rights reserved.
# Copyright (c) 2015-2020 Cisco Systems, Inc.  All rights reserved.
# Copyright (c) 2025      Jeffrey M. Squyres.  All rights reserved.
# $COPYRIGHT$
#
# Subroutine to generate a bunch of Fortran declarations and symbols
#

import argparse
import os
import sys

from pathlib import Path

# File names
file_c_constants_decl = "mpif-c-constants-decl.h"
file_c_constants = "mpif-c-constants.h"
file_f08_types = "mpif-f08-types.h"

# Header comment block
header_comment = """/*
 * Copyright (c) 2015-2025 Research Organization for Information Science
 * and Technology (RIST). All rights reserved.
 * Copyright (c) 2015-2020 Cisco Systems, Inc.  All rights reserved.
 * $COPYRIGHT$
 *
 * This file was generated by gen-mpi-mangling.py.
 */
"""

fortran_header_comment = """!
! Copyright (c) 2015-2025 Research Organization for Information Science
!                         and Technology (RIST). All rights reserved.
! Copyright (c) 2015-2020 Cisco Systems, Inc.  All rights reserved.
! $COPYRIGHT$
!
! This file was generated by gen-mpi-mangling.py.
!"""

def get_fortran_constants(args):
    return {
        'bottom': {
            'c_type': "MPI_Fint",
            'c_name': "mpi_fortran_bottom",
            'f_type': "integer",
            'f_name': "MPI_BOTTOM",
        },
        'in_place': {
            'c_type': "MPI_Fint",
            'c_name': "mpi_fortran_in_place",
            'f_type': "integer",
            'f_name': "MPI_IN_PLACE",
        },
        'unweighted': {
            'c_type': "MPI_Fint",
            'c_name': "mpi_fortran_unweighted",
            'f_type': "integer, dimension(1)",
            'f_name': "MPI_UNWEIGHTED",
        },
        'weights_empty': {
            'c_type': "MPI_Fint",
            'c_name': "mpi_fortran_weights_empty",
            'f_type': "integer, dimension(1)",
            'f_name': "MPI_WEIGHTS_EMPTY",
        },
        'argv_null': {
            'c_type': "char",
            'c_name': "mpi_fortran_argv_null",
            'f_type': "character, dimension(1)",
            'f_name': "MPI_ARGV_NULL",
        },
        'argvs_null': {
            'c_type': "char",
            'c_name': "mpi_fortran_argvs_null",
            'f_type': "character, dimension(1, 1)",
            'f_name': "MPI_ARGVS_NULL",
        },
        'errcodes_ignore': {
            'c_type': "MPI_Fint",
            'c_name': "mpi_fortran_errcodes_ignore",
            'f_type': "integer, dimension(1)",
            'f_name': "MPI_ERRCODES_IGNORE",
        },
        'status_ignore': {
            'c_type': "MPI_Fint",
            'c_dim' : f"[{args.status_size}]",
            'c_name': "mpi_fortran_status_ignore",
            'f_type': "type(MPI_STATUS)",
            'f_name': "MPI_STATUS_IGNORE",
        },
        'statuses_ignore': {
            'c_type': "MPI_Fint",
            'c_dim' : f"[{args.status_size}]",
            'c_name': "mpi_fortran_statuses_ignore",
            'f_type': "type(MPI_STATUS)",
            'f_name': "MPI_STATUSES_IGNORE(1)",
        },
        'buffer_automatic': {
            'c_type': "MPI_Fint",
            'c_name': "mpi_fortran_buffer_automatic",
            'f_type': "integer",
            'f_name': "MPI_BUFFER_AUTOMATIC",
        },
    }

def mangle(name, mangling_type):
    # Mangles a C name based on the chosen Fortran mangling scheme
    if mangling_type == 'plain':
        return name
    elif mangling_type == 'caps':
        return name.upper()
    elif mangling_type == 'single':
        return name + "_"
    elif mangling_type == 'double':
        return name + "__"
    else:
        raise ValueError("Unknown name mangling type")

def gen_c_constants_decl(mangling_type, fortran_constants, args):
    # Generates the mpif-c-constants-decl.h file
    with open(file_c_constants_decl, "w") as f:
        f.write("/* WARNING: This is a generated file!  Edits will be lost! */\n")
        f.write(header_comment)
        f.write("\n/* Note that the rationale for the types of each of these variables is\n")
        f.write("   discussed in ompi/include/mpif-common.h.  Do not change the types\n")
        f.write("   without also changing ompi/runtime/ompi_mpi_init.c and\n")
        f.write("   ompi/include/mpif-common.h. */\n\n")

        for key in sorted(fortran_constants.keys()):
            const = fortran_constants[key]
            mangled_name = mangle(const['c_name'], mangling_type)
            dim = const.get('c_dim', '')
            f.write(f"extern {const['c_type']} {mangled_name}{dim};\n")
            f.write(f"#define OMPI_IS_FORTRAN_{key.upper()}(addr) \\\n")
            f.write(f"        (addr == (void*) &{mangled_name})\n")
            f.write(f"#define OMPI_FORTRAN_{key.upper()}_ADDR() \\\n")
            f.write(f"        (void*) &{mangled_name}\n\n")

def gen_c_constants(mangling_type, fortran_constants, args):
    # Generates the mpif-c-constants.h file
    with open(file_c_constants, "w") as f:
        f.write("/* WARNING: This is a generated file!  Edits will be lost! */\n")
        f.write(header_comment)
        f.write("\n")

        for key in sorted(fortran_constants.keys()):
            const = fortran_constants[key]
            align = f" __opal_attribute_aligned__({args.align}) " if args.align else ' '
            dim = const.get('c_dim', '')
            mangled_name = mangle(const['c_name'], mangling_type)
            f.write(f"{const['c_type']}{align}{mangled_name}{dim};\n")

def gen_f08_types(mangling_type, fortran_constants):
    # Generates the mpif-f08-types.h file
    with open(file_f08_types, "w") as f:
        f.write("! WARNING: This is a generated file!  Edits will be lost! */\n")
        f.write(fortran_header_comment)
        f.write("\n\n")

        for key in sorted(fortran_constants.keys()):
            const = fortran_constants[key]
            mangled_name = mangle(const['c_name'], mangling_type)
            f.write(f"{const['f_type']}, bind(C, name=\"{mangled_name}\") :: {const['f_name']}\n")


def main():
    parser = argparse.ArgumentParser(description="Generate Fortran MPI mangling header files.")
    parser.add_argument('--caps', type=int, default=0,
                        help='Use uppercase mangling')
    parser.add_argument('--plain', type=int, default=0,
                        help='Use plain mangling (no change)')
    parser.add_argument('--single', type=int, default=0,
                        help='Use single underscore suffix mangling')
    parser.add_argument('--double', type=int, default=0,
                        help='Use double underscore suffix mangling')
    parser.add_argument('--status-size', type=int, default=0,
                        help='Length of the Fortran MPI_Status array')
    parser.add_argument('--align', type=int, default=0,
                        help='Alignment of Fortran intengers')

    args = parser.parse_args()

    if args.caps + args.plain + args.single + args.double > 1:
        print("Cannot enable more than one mangling style")
        exit(1)

    mangling_type = None
    if args.caps:
        mangling_type = 'caps'
    elif args.plain:
        mangling_type = 'plain'
    elif args.single:
        mangling_type = 'single'
    elif args.double:
        mangling_type = 'double'

    # If no mangling type is selected, create empty files
    if mangling_type is None:
        print("No Fortran mangling scheme specified. Creating empty files.")
        Path(file_c_constants_decl).touch()
        Path(file_c_constants).touch()
        Path(file_f08_types).touch()
        sys.exit(0)

    # Generate the files based on the selected mangling type
    try:
        fortran_constants = get_fortran_constants(args)
        gen_c_constants_decl(mangling_type, fortran_constants, args)
        gen_c_constants(mangling_type, fortran_constants, args)
        gen_f08_types(mangling_type, fortran_constants)
        print(f"Generated files with '{mangling_type}' mangling.")
        sys.exit(0)
    except Exception as e:
        print(f"Error generating files: {e}", file=sys.stderr)
        sys.exit(1)

if __name__ == "__main__":
    main()
