/*
 * Copyright (c) 2004-2007 The Trustees of Indiana University and Indiana
 *                         University Research and Technology
 *                         Corporation.  All rights reserved.
 * Copyright (c) 2004-2021 The University of Tennessee and The University
 *                         of Tennessee Research Foundation.  All rights
 *                         reserved.
 * Copyright (c) 2004-2008 High Performance Computing Center Stuttgart,
 *                         University of Stuttgart.  All rights reserved.
 * Copyright (c) 2004-2005 The Regents of the University of California.
 *                         All rights reserved.
 * Copyright (c) 2006-2010 Cisco Systems, Inc.  All rights reserved.
 * Copyright (c) 2015      Research Organization for Information Science
 *                         and Technology (RIST). All rights reserved.
 * Copyright (c) 2024      Triad National Security, LLC. All rights
 *                         reserved.
 * Copyright (c) 2025      Advanced Micro Devices, Inc. All rights reserved
 *
 * $COPYRIGHT$
 *
 * Additional copyrights may follow
 *
 * $HEADER$
 */
#include "ompi_config.h"
#include <stdio.h>

#include "ompi/mpi/c/bindings.h"
#include "ompi/runtime/params.h"
#include "ompi/communicator/communicator.h"
#include "ompi/errhandler/errhandler.h"
#include "ompi/request/request.h"
#include "ompi/request/grequest.h"
#include "ompi/memchecker.h"

/* Non blocking status retrieval. Upon completion, the request(s) will
 * not be freed (unlike the test function). A subsequent call to test, wait
 * or free should be executed on the request(s).
 */
PROTOTYPE ERROR_CLASS request_get_status_all(INT count, REQUEST_CONST requests:count, INT_OUT flag,
                                             STATUS_OUT statuses:count)
{
    MEMCHECKER(
       int j;
       for (j = 0; j< count;  j++) {
           memchecker_request(&requests[j]);
       }
    );

    if( MPI_PARAM_CHECK ) {
        int rc = MPI_SUCCESS;

        OMPI_ERR_INIT_FINALIZE(FUNC_NAME);
        if (NULL == requests) {
            rc = MPI_ERR_REQUEST;
        } else {
            /* Need to cast the const away, since the request argument for most
            ** MPI functions invoking this functionality does not have the const
            ** argument
            */
            if(!ompi_request_check_same_instance((MPI_Request *)requests, count) ) {
                rc = MPI_ERR_REQUEST;
            }
        }
        if ((NULL == flag) || (count < 0)) {
            rc = MPI_ERR_ARG;
        }
        OMPI_ERRHANDLER_NOHANDLE_CHECK(rc, rc, FUNC_NAME);
    }

    if (OPAL_UNLIKELY(0 == count)) {
        *flag = true;
        return MPI_SUCCESS;
    }

    bool all_done;

#if OPAL_ENABLE_PROGRESS_THREADS == 0
    bool do_it_once = true;
 recheck_request_status:
#endif

    opal_atomic_mb();
    int i;
    all_done = true;
    for (i = 0; i < count; i++) {
        if( (requests[i] == MPI_REQUEST_NULL) || (requests[i]->req_state == OMPI_REQUEST_INACTIVE) ||
            (requests[i]->req_complete) ) {
            continue;
        }
        all_done = false;
        break;
    }

    if (!all_done) {
#if OPAL_ENABLE_PROGRESS_THREADS == 0
        if(do_it_once) {
            /* If we run the opal_progress then check the status of the
               request before leaving. We will call the opal_progress only
               once per call. */
            opal_progress();
            do_it_once = false;
            goto recheck_request_status;
        }
#endif
        *flag = false;
        return MPI_SUCCESS;
    }

    for (i = 0; i < count; i++) {
        if( (requests[i] == MPI_REQUEST_NULL) || (requests[i]->req_state == OMPI_REQUEST_INACTIVE) ) {
            if (MPI_STATUS_IGNORE != statuses) {
                OMPI_COPY_STATUS(&statuses[i], ompi_status_empty, false);
            }
        }
        /* If this is a generalized request, we *always* have to call
           the query function to get the status (MPI-2:8.2), even if
           the user passed STATUS_IGNORE. */
        if (OMPI_REQUEST_GEN == requests[i]->req_type) {
            ompi_grequest_invoke_query(requests[i], &requests[i]->req_status);
        }
        if (MPI_STATUS_IGNORE != statuses) {
            OMPI_COPY_STATUS(&statuses[i], requests[i]->req_status, false);
        }
    }

    *flag = true;
    return MPI_SUCCESS;
}
